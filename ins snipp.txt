{
	"Write a python program to implement Ceaser Cipher.": {
		"prefix": "Write a python program to implement Ceaser Cipher.",
		"body": [
			"def encrypt(string, shift):",
			"    cipher = ''",
			"    for char in string:",
			"        if char == ' ':",
			"            cipher = cipher + char",
			"        elif char.isupper():",
			"            cipher = cipher + chr((ord(char) + shift - 65) % 26 + 65)",
			"        else:",
			"            cipher = cipher + chr((ord(char) + shift - 97) % 26 + 97)",
			"    return cipher",
			"",
			"def decrypt(string, shift):",
			"    cipher = ''",
			"    for char in string:",
			"        if char == ' ':",
			"            cipher = cipher + char",
			"        elif char.isupper():",
			"            cipher = cipher + chr((ord(char) + (26 - shift) - 65) % 26 + 65)",
			"        else:",
			"            cipher = cipher + chr((ord(char) + (26 - shift) - 97) % 26 + 97)",
			"    return cipher",
			"",
			"text = input(\"Enter String: \")",
			"s = int(input(\"Enter Shift Number: \"))",
			"option = int(input(\"1. For Encrypt \\n2. For Decrypt\\n Enter Your choice: \"))",
			"print(\"Original String : \", text)",
			"if (option == 1):",
			"    print(\"After Encryption \", encrypt(text, s))",
			"else:",
			"    print(\"After Decryption:\", decrypt(text, s))"
		],
		"description": "Implements the Caesar Cipher for encryption and decryption."
	},
	"Write a python program to implement Mono-alphabetic Cipher.": {
		"prefix": "Write a python program to implement Mono-alphabetic Cipher.",
		"body": [
			"alphabet = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"",
			"keyword = \"ZYXWVUTSRQPONMLKJIHGFEDCBA\"  # Reversed alphabet as a simple substitution key",
			"",
			"def encrypt(Plaintext):",
			"    result = \"\"",
			"    for char in Plaintext:",
			"        if char in alphabet:",
			"            num = alphabet.find(char)",
			"            result += keyword[num]",
			"        else:",
			"            result += char",
			"    print(\"Encrypted Text:\", result)",
			"",
			"def decrypt(Ciphertext):",
			"    result = \"\"",
			"    for char in Ciphertext:",
			"        if char in keyword:",
			"            num = keyword.find(char)",
			"            result += alphabet[num]",
			"        else:",
			"            result += char",
			"    print(\"Decrypted Text:\", result)",
			"",
			"while True:",
			"    try:",
			"        n = int(input(\"Enter Value:\\n1) Encrypt Text\\n2) Decrypt Text\\n3) See Key\\n4) Exit\\nChoice: \"))",
			"    except ValueError:",
			"        print(\"Invalid input; please enter a number between 1 and 4.\")",
			"        continue",
			"    match n:",
			"        case 1:",
			"            Plaintext = input(\"Enter Text to Encrypt: \")",
			"            encrypt(Plaintext.upper())",
			"        case 2:",
			"            Ciphertext = input(\"Enter Text to Decrypt: \")",
			"            decrypt(Ciphertext.upper())",
			"        case 3:",
			"            print(\"Substitution Key (Keyword):\", keyword)",
			"        case 4:",
			"            print(\"Exiting the program.\")",
			"            break",
			"        case _:",
			"            print(\"Invalid Input; Enter Again!!\")"
		],
		"description": "Implements the Mono-alphabetic Cipher for encryption and decryption."
	},
	"Write a python program to implement Playfair Cipher.": {
		"prefix": "Write a python program to implement Playfair Cipher.",
		"body": [
			"def to_diagraphs(text):",
			"    text = text.upper().replace('J', 'I').replace(' ', '')",
			"    diagraphs = []",
			"    i = 0",
			"    while i < len(text):",
			"        a = text[i]",
			"        if i + 1 == len(text) or a == text[i+1]:",
			"            b = 'X'",
			"            i += 1",
			"        else:",
			"            b = text[i+1]",
			"            i += 2",
			"        diagraphs.append(a + b)",
			"    return diagraphs",
			"",
			"def generate_matrix(key):",
			"    key = key.upper().replace('J', 'I').replace(' ', '')",
			"    alphabet = 'ABCDEFGHIKLMNOPQRSTUVWXYZ'",
			"    matrix = []",
			"    for char in key:",
			"        if char not in matrix:",
			"            matrix.append(char)",
			"    for char in alphabet:",
			"        if char not in matrix:",
			"            matrix.append(char)",
			"    return [matrix[i:i+5] for i in range(0, 25, 5)]",
			"",
			"def find_pos(matrix, char):",
			"    for r, row in enumerate(matrix):",
			"        for c, col_char in enumerate(row):",
			"            if col_char == char:",
			"                return r, c",
			"",
			"def encrypt_decrypt(diagraphs, matrix, mode):",
			"    result = ''",
			"    for d in diagraphs:",
			"        r1, c1 = find_pos(matrix, d[0])",
			"        r2, c2 = find_pos(matrix, d[1])",
			"        if r1 == r2: # Same row",
			"            result += matrix[r1][(c1 + mode) % 5] + matrix[r2][(c2 + mode) % 5]",
			"        elif c1 == c2: # Same column",
			"            result += matrix[(r1 + mode) % 5][c1] + matrix[(r2 + mode) % 5][c2]",
			"        else: # Rectangle",
			"            result += matrix[r1][c2] + matrix[r2][c1]",
			"    return result",
			"",
			"key = input(\"Enter key: \")",
			"matrix = generate_matrix(key)",
			"",
			"while True:",
			"    choice = input(\"\\n1. Encryption\\n2. Decryption\\n3. Exit\\nEnter Your Choice: \\n\")",
			"    if choice == '1':",
			"        msg = input(\"ENTER MSG: \")",
			"        diagraphs = to_diagraphs(msg)",
			"        cipher_text = encrypt_decrypt(diagraphs, matrix, 1)",
			"        print(\"CIPHER TEXT:\", cipher_text)",
			"    elif choice == '2':",
			"        msg = input(\"ENTER CIPHER TEXT: \")",
			"        diagraphs = to_diagraphs(msg)",
			"        plain_text = encrypt_decrypt(diagraphs, matrix, -1)",
			"        print(\"PLAIN TEXT:\", plain_text)",
			"    elif choice == '3':",
			"        exit()",
			"    else:",
			"        print(\"Choose correct choice\")"
		],
		"description": "Implements the Playfair Cipher for encryption and decryption."
	},
	"Write a python program to implement Vernam Cipher.": {
		"prefix": "Write a python program to implement Vernam Cipher.",
		"body": [
			"def vernam_cipher(text, key, encrypt=True):",
			"    result = \"\"",
			"    for i in range(len(text)):",
			"        char_val = ord(text[i]) - ord('a')",
			"        key_val = ord(key[i]) - ord('a')",
			"        if encrypt:",
			"            encrypted_val = (char_val + key_val) % 26",
			"        else:",
			"            encrypted_val = (char_val - key_val + 26) % 26",
			"        result += chr(encrypted_val + ord('a'))",
			"    return result",
			"",
			"if __name__ == \"__main__\":",
			"    plain_text = ''.join(input(\"Enter Plaintext: \").lower().split())",
			"    key = ''.join(input(\"Enter Key: \").lower().split())",
			"",
			"    if len(key) != len(plain_text):",
			"        print(\"Invalid Key! Key must be the same length as the plaintext.\")",
			"        exit()",
			"",
			"    cipher_text = vernam_cipher(plain_text, key, True)",
			"    print(\"CipherText: \", cipher_text)",
			"",
			"    decrypted_text = vernam_cipher(cipher_text, key, False)",
			"    print(\"PlainBack: \", decrypted_text)"
		],
		"description": "Implements the Vernam Cipher for encryption and decryption."
	},
	"Write a python program to implement Simple Columnar Transposition Cipher.": {
		"prefix": "Write a python program to implement Simple Columnar Transposition Cipher.",
		"body": [
			"import math",
			"",
			"key = \"RICK\"",
			"",
			"def encryptMessage(msg):",
			"    cipher = \"\"",
			"    msg = msg.replace(' ', '_')",
			"    k_indx = 0",
			"    msg_len = float(len(msg))",
			"    msg_lst = list(msg)",
			"    key_lst = sorted(list(key))",
			"    col = len(key)",
			"    row = int(math.ceil(msg_len / col))",
			"    fill_null = int((row * col) - msg_len)",
			"    msg_lst.extend('_' * fill_null)",
			"    matrix = [msg_lst[i: i + col] for i in range(0, len(msg_lst), col)]",
			"    for _ in range(col):",
			"        curr_idx = key.index(key_lst[k_indx])",
			"        cipher += ''.join([row[curr_idx] for row in matrix])",
			"        k_indx += 1",
			"    return cipher",
			"",
			"def decryptMessage(cipher):",
			"    msg = \"\"",
			"    k_indx = 0",
			"    msg_indx = 0",
			"    msg_len = float(len(cipher))",
			"    msg_lst = list(cipher)",
			"    col = len(key)",
			"    row = int(math.ceil(msg_len / col))",
			"    key_lst = sorted(list(key))",
			"    dec_cipher = []",
			"    for _ in range(row):",
			"        dec_cipher += [[None] * col]",
			"    for _ in range(col):",
			"        curr_idx = key.index(key_lst[k_indx])",
			"        for j in range(row):",
			"            dec_cipher[j][curr_idx] = msg_lst[msg_indx]",
			"            msg_indx += 1",
			"        k_indx += 1",
			"    try:",
			"        msg = ''.join(sum(dec_cipher, []))",
			"    except TypeError:",
			"        raise TypeError(\"This program cannot handle repeating words.\")",
			"    null_count = msg.count('_')",
			"    if null_count > 0:",
			"        return msg[:-null_count].replace('_', ' ')",
			"    return msg.replace('_', ' ')",
			"",
			"msg = \"Come Home Tomorrow\"",
			"cipher = encryptMessage(msg)",
			"print(\"Encrypted Message: {}\".format(cipher))",
			"print(\"Decrypted Message: {}\".format(decryptMessage(cipher)))"
		],
		"description": "Implements the Simple Columnar Transposition Cipher."
	},
	"Write a python program to implement Railfence Cipher.": {
		"prefix": "Write a python program to implement Railfence Cipher.",
		"body": [
			"def encryptRailFence(text, key):",
			"    rail = [['\\n' for i in range(len(text))] for j in range(key)]",
			"    dir_down = False",
			"    row, col = 0, 0",
			"    for i in range(len(text)):",
			"        if (row == 0) or (row == key - 1):",
			"            dir_down = not dir_down",
			"        rail[row][col] = text[i]",
			"        col += 1",
			"        if dir_down:",
			"            row += 1",
			"        else:",
			"            row -= 1",
			"    result = []",
			"    for i in range(key):",
			"        for j in range(len(text)):",
			"            if rail[i][j] != '\\n':",
			"                result.append(rail[i][j])",
			"    return(\"\".join(result))",
			"",
			"def decryptRailFence(cipher, key):",
			"    rail = [['\\n' for i in range(len(cipher))] for j in range(key)]",
			"    dir_down = None",
			"    row, col = 0, 0",
			"    for i in range(len(cipher)):",
			"        if row == 0:",
			"            dir_down = True",
			"        if row == key - 1:",
			"            dir_down = False",
			"        rail[row][col] = '*'",
			"        col += 1",
			"        if dir_down:",
			"            row += 1",
			"        else:",
			"            row -= 1",
			"    index = 0",
			"    for i in range(key):",
			"        for j in range(len(cipher)):",
			"            if ((rail[i][j] == '*') and (index < len(cipher))):",
			"                rail[i][j] = cipher[index]",
			"                index += 1",
			"    result = []",
			"    row, col = 0, 0",
			"    for i in range(len(cipher)):",
			"        if row == 0:",
			"            dir_down = True",
			"        if row == key - 1:",
			"            dir_down = False",
			"        if (rail[row][col] != '*'):",
			"            result.append(rail[row][col])",
			"            col += 1",
			"        if dir_down:",
			"            row += 1",
			"        else:",
			"            row -= 1",
			"    return(\"\".join(result))",
			"",
			"if __name__ == \"__main__\":",
			"    print(encryptRailFence(\"attack at once\", 2))",
			"    print(encryptRailFence(\"defend the east wall\", 3))",
			"    print(decryptRailFence(\"atc toctaka ne\", 2))",
			"    print(decryptRailFence(\"dnhaweedtees alf tl\", 3))"
		],
		"description": "Implements the Rail Fence Cipher for encryption and decryption."
	},
	"RSA Encryption and Decryption": {
		"prefix": "RSA Encryption and Decryption",
		"body": [
			"from Crypto.PublicKey import RSA",
			"from Crypto.Cipher import PKCS1_OAEP",
			"import binascii",
			"",
			"# Generate RSA key pair (public and private key)",
			"keyPair = RSA.generate(1024)",
			"",
			"# Get the public key",
			"pubKey = keyPair.publickey()",
			"",
			"# Print the public key components: modulus (n) and exponent (e)",
			"print(f\"Public key: (n={hex(pubKey.n)}, e={hex(pubKey.e)})\")",
			"",
			"# Export the public key in PEM format and print it",
			"pubKeyPEM = pubKey.export_key()",
			"print(pubKeyPEM.decode('utf-8'))",
			"",
			"# Print the private key components: modulus (n) and private exponent (d)",
			"print(f\"Private key: (n={hex(keyPair.n)}, d={hex(keyPair.d)})\")",
			"",
			"# Export the private key in PEM format and print it",
			"privKeyPEM = keyPair.export_key()",
			"print(privKeyPEM.decode('utf-8'))",
			"",
			"# Message to be encrypted (convert the string to bytes)",
			"msg = b'Hello Class'",
			"",
			"# Encrypt the message using the public key and PKCS1_OAEP",
			"encryptor = PKCS1_OAEP.new(pubKey)",
			"encrypted = encryptor.encrypt(msg)",
			"",
			"# Print the encrypted message in hexadecimal format",
			"print(\"Encrypted:\", binascii.hexlify(encrypted).decode('utf-8'))",
			"",
			"# Decrypt the message using the private key",
			"decryptor = PKCS1_OAEP.new(keyPair)",
			"decrypted = decryptor.decrypt(encrypted)",
			"print('Decrypted:', decrypted.decode('utf-8'))"
		],
		"description": "Implements the RSA algorithm for public-key encryption and decryption."
	},
	"MD5 Hashing": {
		"prefix": "MD5 Hashing",
		"body": [
			"import hashlib",
			"",
			"# Creating an MD5 hash object for the byte string 'Hello'",
			"result = hashlib.md5(b'Hello')",
			"",
			"# Creating another MD5 hash object for the byte string 'Fello'",
			"result1 = hashlib.md5(b'Fello')",
			"",
			"# Printing a message indicating what the following output represents",
			"print(\"The byte equivalent of hash is: \", end=\"\")",
			"",
			"# Printing the digest (byte equivalent) of the hash object 'result'",
			"print(result.digest())",
			"",
			"# Printing a message indicating what the following output represents",
			"print(\"The byte equivalent of hash is: \", end=\"\")",
			"",
			"# Printing the digest (byte equivalent) of the hash object 'result1'",
			"print(result1.digest())"
		],
		"description": "Generates MD5 hash for given byte strings."
	},
	"SHA Hashing": {
		"prefix": "SHA Hashing",
		"body": [
			"import hashlib",
			"",
			"# Prompting the user to enter a value to encode",
			"str_to_encode = input(\"Enter the value to encode: \")",
			"",
			"# Encoding the input string to bytes and creating a SHA-1 hash object",
			"result = hashlib.sha1(str_to_encode.encode())",
			"",
			"# Printing a message indicating what the following output represents",
			"print(\"The hexadecimal equivalent of SHA1 is: \")",
			"",
			"# Printing the hexadecimal representation of the SHA-1 hash",
			"print(result.hexdigest())"
		],
		"description": "Generates SHA-1 hash for a user-provided string."
	},
	"Digital Signature with RSA": {
		"prefix": "Digital Signature with RSA",
		"body": [
			"from Crypto.PublicKey import RSA",
			"from Crypto.Signature import pkcs1_15",
			"from Crypto.Hash import SHA256",
			"",
			"# Generate a new RSA key pair",
			"key = RSA.generate(2048)",
			"private_key = key.export_key()",
			"public_key = key.publickey().export_key()",
			"",
			"# Document to be signed",
			"original_document = b\"This is the original document content.\"",
			"",
			"# Hash the original document",
			"original_hash = SHA256.new(original_document)",
			"",
			"# Sign the hash with the private key",
			"signature = pkcs1_15.new(RSA.import_key(private_key)).sign(original_hash)",
			"",
			"# Document to be verified (can be original or modified)",
			"modified_document = b\"This is the original document content.\"",
			"# modified_document = b\"This is a modified document.\"",
			"",
			"# Hash the document that needs verification",
			"modified_hash = SHA256.new(modified_document)",
			"",
			"# Verify the signature with the public key",
			"try:",
			"    pkcs1_15.new(RSA.import_key(public_key)).verify(modified_hash, signature)",
			"    print(\"Signature is valid.\")",
			"except (ValueError, TypeError):",
			"    print(\"Signature is invalid.\")"
		],
		"description": "Implements digital signature algorithms using RSA-based signatures."
	},
	"Key Exchange using Diffie-Hellman": {
		"prefix": "Key Exchange using Diffie-Hellman",
		"body": [
			"if __name__ == '__main__':",
			"    # Publicly known numbers",
			"    q = 23  # A prime number",
			"    alpha = 9  # A primitive root modulo q",
			"    print('The Value of q is: %d' % q)",
			"    print('The Value of alpha is: %d' % alpha)",
			"",
			"    # Alice's private key",
			"    XA = 4",
			"    print('Secret Number for Alice is: %d' % XA)",
			"",
			"    # Alice's public key",
			"    YA = int(pow(alpha, XA, q))",
			"",
			"    # Bob's private key",
			"    XB = 6",
			"    print('Secret Number for Bob is: %d' % XB)",
			"",
			"    # Bob's public key",
			"    YB = int(pow(alpha, XB, q))",
			"",
			"    # Alice computes the shared secret key",
			"    k1 = int(pow(YB, XA, q))",
			"",
			"    # Bob computes the shared secret key",
			"    k2 = int(pow(YA, XB, q))",
			"",
			"    print('Secret key for Alice is: %d' % k1)",
			"    print('Secret Key for Bob is: %d' % k2)"
		],
		"description": "Implements the Diffie-Hellman key exchange algorithm."
	},
	"SSL/TLS Echo Server": {
		"prefix": "SSL/TLS Echo Server",
		"body": [
			"import socket",
			"import ssl",
			"",
			"context = ssl.SSLContext(ssl.PROTOCOL_TLS_SERVER)",
			"context.load_cert_chain(certfile='localhost.crt', keyfile='localhost.key')",
			"",
			"with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as server:",
			"    server.bind(('', 4434))",
			"    server.listen(5)",
			"    print(\"Server is listening on port 4434...\")",
			"    while True:",
			"        client_socket, address = server.accept()",
			"        print(f\"Connection from {address[0]}:{address[1]}\")",
			"        ssl_socket = context.wrap_socket(client_socket, server_side=True)",
			"        try:",
			"            while True:",
			"                data = ssl_socket.recv(1024)",
			"                if not data:",
			"                    break",
			"                decoded = data.decode('utf-8')",
			"                print(f\"[{address[0]}:{address[1]}] {decoded}\")",
			"                ssl_socket.sendall(data)",
			"        finally:",
			"            print(f\"Connection from {address[0]}:{address[1]} closed\")",
			"            ssl_socket.close()"
		],
		"description": "Creates a simple SSL/TLS echo socket server."
	},
	"SSL/TLS Echo Client": {
		"prefix": "SSL/TLS Echo Client",
		"body": [
			"import socket",
			"import ssl",
			"",
			"context = ssl.SSLContext(ssl.PROTOCOL_TLS_CLIENT)",
			"context.load_verify_locations('localhost.crt')",
			"",
			"with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as sock:",
			"    sock.settimeout(10)",
			"    ssl_sock = context.wrap_socket(sock, server_hostname='localhost')",
			"    ssl_sock.connect(('localhost', 4434))",
			"    print(\"Connected to server on port 4434...\")",
			"    while True:",
			"        msg = input(\"> \")",
			"        if not msg:",
			"            break",
			"        ssl_sock.sendall(bytes(msg, 'utf-8'))",
			"        data = ssl_sock.recv(1024)",
			"        print(\"Server responded: \", data.decode('utf-8'))"
		],
		"description": "Creates a simple SSL/TLS echo socket client."
	}
}